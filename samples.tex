\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script named $hello\_world.rb$ containing the following:
\begin{verbatim}
puts 'Hello world'
\end{verbatim}
Now consider a \lang{} program like the following:
\begin{Verbatim}[numbers=left]
#Hello World
a = Job(name="a", script="hello_world.rb")
run(a)
if (a.perror() == 0){
    print a.stdout()
}
else{
    print a.error()
}
\end{Verbatim}

In the above code snippet we demonstrate how to create of a job with name `a'.
This job is then initialized with the script of our hello world program and
workers the default value (1). In line 3, $run()$, disseminates job `a'. 
\lang{} will find an idle worker and execute our script hello\_world.rb.
Afterwards, error code of job `a' is evaluated. If script hello\_world.rb terminates properly (line 4)
,its stdout is printed. Otherwise, an error string is printed.

\subsection*{Example Program 2:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
run((a <-> b) -> c)
\end{Verbatim}

This example uses all concurrency capabilities of \lang{}.
3 jobs are created, and dependencies amongst them are specified.
In this case each job can run on different number of workers.
Line 4  shows a simple example on how to introduce dependencies in \lang{}.
The expression $(a <-> b)$ states that jobs `a' and `b' can
run concurrently in different servers. Afterwards,  $-> c$ that the job `c' must run after the successful termination
of the previous job/s (jobs `a' and `b').

You can see that \lang{} offers an easy way to distinguish between\\
concurrent and not concurrent jobs. This will help user create and easily distribute batch processes.\\
\\

\subsection*{Example Program 3:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
d = Job(name="d", "nimbledriod.py")
((a\mytilde>(b\mytilde c))\mytilde<d)
run((a,b,c,d)
\end{Verbatim}

This example demonstrates `soft' dependencies in \lang{}.\\
`Soft' dependencies must be in one line. Operators
are left associate but we use parenthesis in order to help
user understand how `soft' dependencies work. Line 5 is where all
magic happens. First, $(b\sim c)$ means that jobs `b' and `c' can run 
sychronous if there are enough resources. Second,
$(a\sim>expr)$ means that job `a' should run before \textit{expr}. 
Finally $(expr\sim<d)$ means that job `d' should run before \textit{expr}.\\
\\

\subsection*{Example Program 4:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
d = Job(name="d", "nimbledriod.py")
c.add_dependency([b,d])
a\mytilde<b
run(a,b,c,d)
\end{Verbatim}

This example shows a third way to introduce dependencies.
With function \textit{add\_dependency} user adds to a job
a list of other jobs to be dependant on. First, execution of job `b' 
will start prior to job `a' since there is a soft dependency introduced 
in line 6. Job `a' will start as soon as job `b' terminates.
In addition job `c' is blocked until both jobs `b' and `d' terminate.
Since there is no dependency between `b' and `d', `d' may start execution  
in any worker. Upon termination of `d', job `c' will be eligible to run.
