\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script file named $hello\_world.rb$ containing the following script
\begin{verbatim}
puts 'Hello world'
\end{verbatim}

Now consider a Maestro program like the following:
\begin{verbatim}
#Hello World
Job a = Job.new(name="a", script="hello_world.rb")
run(a)
if (a.perror()[0] == 0){
    print a.stdout()
}
else{
    print a.perror()[1]
}
\end{verbatim}
In this example we can see the declaration of a job with name `a' at line 2.\\
We initialize it with the script name of our hello world script and\\
we leave the workers with the default 1 value. In line 3 we $run()$\\
our job. Our language will find a not loaded worker and run our command.\\
After the exection it will populate the internal values of the `Job'\\
class. Afterwards we are testing if it returned properly (line 4). If it\\
returned 0 (the general code that execution terminated correctly) we are\\
printing the stdout variable of our job (line 5). Otherwise we are\\
printing the error string (line 8) that our program returned in order\\
to understand what happened with our example.\\

\subsection*{Example Program 2:}
\begin{verbatim}
Job a = Job.new(name="a", script="abc.pl", workers=5)
Job b = Job.new(name="b", script="xRay.rb", workers=3)
run(a --> b)
\end{verbatim}

This program creates two jobs, job $A$ and job $B$. It runs job $A$ first on the requested number of workers
and if successful, runs job $B$. If job $A$ fails, job $B$ is not initiated.
\\

\subsection*{Example Program 3:}
\begin{verbatim}
Job a = Job.new(name="a", script="abc.pl", workers=5)
Job b = Job.new(name="b", script="xRay.rb", workers=3)
run(a <--> b)
\end{verbatim}

This program creates two jobs, job $A$ and job $B$ and runs them in parellel in their respective number of requested workers.
Unlike the previous example the outcome of one job is not dependent on the execution of the other job(s).
\\

\subsection*{Example Program 4:}
\begin{verbatim}
Job a = Job.new(name="a", script="abc.pl", workers=5)
Job b = Job.new(name="b", script="xRay.rb", workers=3)
Job c = Job.new(name="c", "telesphorus.py")
run((a <--> b) --> c)
\end{verbatim}

This program creates and runs two jobs, $A$ and $B$ in parallel, on a few
workers. And then it runs job $C$ on some workers, only after both $A$
and $B$ succeed. The important point to be noted here is that job $C$ is 
only excuted AFTER jobs $A$ and $B$ have successfully been excuted on workers.
\\

\subsection*{Example Program 5:}
\begin{verbatim}
func an_hour_after(Job j) {
  return func () {
    j.finish_time && j.finish_time - Time.now > Time.hour(1)
  }
}

Job old_b = nil
for i in range(0,10) {
  a = Job.new(name="a", script='send_email_batch.rb')
  b = Job.new(name="b", script='collect_data.rb')
  b.add_func_dependency( an_hour_after(a) )
  Job c = Job.new(name="c", script='analyze.py')
  run(old_b --> a --> b --> c)
  old_b = b
}
\end{verbatim}
This program makes measurements in 3 steps:
Populate
Collect Data
Analyse
\\

All programs are executed using the 'maestro' command.
\\
