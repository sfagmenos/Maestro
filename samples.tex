\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script file named $hello\_world.rb$ containing the following script
prints 'Hello world'

Now consider a Maestro program like the following:
\begin{lstlisting}
Job a = Job.new(script="hello_world.rb", workers=1)
run(a)
\end{lstlisting}

This program creates a jobs, job $A$ that will run the hello world script we created. 
It runs job $A$ on the requested number of workers and prints out 'Hello world'.
\\

\subsection*{Example Program 2:}
\begin{lstlisting}
Job a = Job.new(script="abc.pl", workers=5) /* job scripts */
Job b = Job.new(script="xRay.rb", workers=3)
run(a --> b)
\end{lstlisting}

This program creates two jobs, job $A$ and job $B$. It runs job $A$ first on the requested number of workers
and if successful, runs job $B$. If job $A$ fails, job $B$ is not initiated.
\\

\subsection*{Example Program 3:}
\begin{lstlisting}
Job a = Job.new(script="abc.pl", workers=5) /* job scripts */
Job b = Job.new(script="xRay.rb", workers=3)
run(a <--> b)
\end{lstlisting}

This program creates two jobs, job $A$ and job $B$ and runs them in parellel in their respective number of requested workers.
Unlike the previous example the outcome of one job is not dependent on the execution of the other job(s).
\\

\subsection*{Example Program 4:}
\begin{lstlisting}
Job a = Job.new(script="abc.pl", workers=5) /* job scripts */
Job b = Job.new(script="xRay.rb", workers=3)
Job c = Job.new("telesphorus.py")
run((a <--> b) --> c)
\end{lstlisting}

This program creates and runs two jobs, $A$ and $B$ in parallel, on a few
workers. And then it runs job $C$ on some workers, only after both $A$
and $B$ succeed. The important point to be noted here is that job $C$ is 
only excuted AFTER jobs $A$ and $B$ have successfully been excuted on workers.
\\

\subsection*{Example Program 5:}
\begin{lstlisting}
func an_hour_after(Job j) {
  return func () {
    j.finish_time && j.finish_time - Time.now > Time.hour(1)
  }
}

Job old_b = nil
for i in range(0,10) {
  a = Job.new(script='send_email_batch.rb', workers=1)
  b = Job.new(script='collect_data.rb', workers=1)
  b.add_func_dependency( an_hour_after(a) )
  Job c = Job.new(script='analyze.py')
  run(old_b --> a --> b --> c)
  old_b = b
}
\end{lstlisting}
This program makes measurements in 3 steps:
Populate
Collect Data
Analyse
\\

All programs are executed using the 'maestro' command.
\\
