\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script file named $hello\_world.rb$ containing the following script
\begin{verbatim}
puts 'Hello world'
\end{verbatim}
Now consider a \lang{} program like the following:
\begin{Verbatim}[numbers=left]
#Hello World
a = Job(name="a", script="hello_world.rb")
run(a)
if (a.perror() == 0){
    print a.stdout()
}
else{
    print a.error()
}
\end{Verbatim}

In this example we can see the declaration of a job with name `a' at line 2.\\
We initialize it with the script name of our hello world script and\\
we leave the workers with the default 1 value. In line 3 we $run()$\\
our job. Our language will find a not loaded worker and run our command.\\
After the exection it will populate the internal values of the `Job'\\
class. Afterwards we are testing if it returned properly (line 4). If it\\
returned 0 (the general code that execution terminated correctly) we are\\
printing the stdout variable of our job (line 5). Otherwise we are\\
printing the error string (line 8) that our program returned in order\\
to understand what happened with our example.\\

\subsection*{Example Program 2:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
run(a -> b)
\end{Verbatim}

In this example we are creating 2 jobs. You can see in this example that\\
we are stating in how many workers we want this script ot run. How to \\
state workers will see this in another example. In line 3 we can an\\
example on how to state that one job must run before the other.\\
The job `a' must run in the 5 workers and terminate correct in all\\
of the workers. Then the job `b' will run in 3 workers.
\\

\subsection*{Example Program 3:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
run(a <-> b)
\end{Verbatim}

This example is the same as the 2nd example with one big difference.\\
Here we demonstrate how to run 2 jobs asychronous. You can see that\\
the only difference is the operator inside the run function.\\

You can see that \lang{} offers an easy way to distinguish between\\
the concurrent and not concurrent jobs. This will help developers and\\
not computer scientists to create easily distributable batch proccesses.\\

\subsection*{Example Program 4:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
run((a <-> b) -> c)
\end{Verbatim}

This 4th example we are taking full capabilities of \lang{}.\\
We are creating 3 jobs. Without creating any real dependency,\\
the 2 jobs (`a',`b') will run asychronous and when this jobs\\
terminate successfully the 3rd job `c' will start.\\
In order for the 3rd job to start the first 2 jobs must terminate\\
in all of the workers.\\

\subsection*{Example Program 5:}
\begin{Verbatim}[numbers=left]
func an_hour_after(Job j) {
  return func () {
    j.finish_time && j.finish_time - Time.now > Time.hour(1)
  }
}

Job old_b = nil
for i in range(0,10) {
  a = Job(name="a", script='send_email_batch.rb')
  b = Job(name="b", script='collect_data.rb')
  b.add_func_dependency( an_hour_after(a) )
  c = Job(name="c", script='analyze.py')
  run(old_b -> a -> b -> c)
  old_b = b
}
\end{Verbatim}
This program makes measurements in 3 steps:
Populate
Collect Data
Analyse
\\

All programs are executed using the 'maestro' command.
\\
