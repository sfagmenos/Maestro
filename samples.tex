\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script named $hello\_world.rb$ containing the following:
\begin{verbatim}
puts 'Hello world'
\end{verbatim}
Now consider a \lang{} program like the following:
\begin{Verbatim}[numbers=left]
#Hello World
a = Job(name="a", script="hello_world.rb")
run(a)
\end{Verbatim}

In the above code snippet we demonstrate how to create of a job with name `a'.
This job is then initialized with the script of our hello world program and
workers the default value (1). In line 3, $run()$, disseminates job `a'. 
\lang{} will find an idle worker and execute our script hello\_world.rb.
Afterwards, error code of job `a' is evaluated. If script hello\_world.rb terminates properly (line 4)
,its stdout is printed. Otherwise, an error string is printed.

\subsection*{Example Program 2:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
run((a <-> b) -> c)
\end{Verbatim}

This example uses all concurrency capabilities of \lang{}.
3 jobs are created, and dependencies amongst them are specified.
In this case each job can run on different number of workers.
Line 4  shows a simple example on how to introduce dependencies in \lang{}.
The expression $(a <-> b)$ states that jobs `a' and `b' can
run concurrently in different servers. Afterwards,  $-> c$ that the job `c' must run after the successful termination
of the previous job/s (jobs `a' and `b').

You can see that \lang{} offers an easy way to distinguish between\\
concurrent and not concurrent jobs. This will help user create and easily distribute batch processes.\\
\\

\subsection*{Example Program 3:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
d = Job(name="d", "nimbledriod.py")
((a\mytilde>(b\mytilde c))\mytilde<d)
run((a,b,c,d)
\end{Verbatim}

This example demonstrates `soft' dependencies in \lang{}.\\
`Soft' dependencies must be in one line. Operators
are left associate but we use parenthesis in order to help
user understand how `soft' dependencies work. Line 5 is where all
magic happens. First, $(b\sim c)$ means that jobs `b' and `c' can run 
sychronous if there are enough resources. Second,
$(a\sim>expr)$ means that job `a' should run before \textit{expr}. 
Finally $(expr\sim<d)$ means that job `d' should run before \textit{expr}.\\
\\

\subsection*{Example Program 4:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
a -> Wait(3600) -> b
run(b)
\end{Verbatim}

This examples shows how to use a dummy waiting Job to add time dependencies
between jobs. First, execution of job `b' will start only on success of 'a',
and of a one hour wait.

\subsection*{Example Program 5:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job("split.rb", "/tmp/big_file_name.data")
maps = map(a, "map.rb")
red = reduce(maps, "reduce.rb")
run(red)
\end{Verbatim}

This example shows how to use the map/reduce built in functions to distribute data
analysis of a big file. This assumes that all workers have access to the file (e.g.
distributed file system), or that split.rb scps the pieces of file in the workers.
Then map will create one Job per output line of split.rb. This Job will be the map.rb
script and have as argument one line of split output. Reduce will then...
