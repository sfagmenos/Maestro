\section{Sample Programs}
\label{sect:samples}
\subsection*{Example Program 1:}
Consider a Ruby script file named $hello\_world.rb$ containing the following script
\begin{verbatim}
puts 'Hello world'
\end{verbatim}
Now consider a \lang{} program like the following:
\begin{Verbatim}[numbers=left]
#Hello World
a = Job(name="a", script="hello_world.rb")
run(a)
if (a.perror() == 0){
    print a.stdout()
}
else{
    print a.error()
}
\end{Verbatim}

In this example we can see the declaration of a job with name `a' at line 2.\\
We initialize it with the script name of our hello world script and\\
we leave the workers with the default 1 value. In line 3 we $run()$\\
our job. Our language will find a not loaded worker and run our command.\\
After the exection it will populate the internal values of the `Job'\\
class. Afterwards we are testing if it returned properly (line 4). If it\\
returned 0 (the general code that execution terminated correctly) we are\\
printing the stdout variable of our job (line 5). Otherwise we are\\
printing the error string (line 8) that our program returned in order\\
to understand what happened with our example.\\

\subsection*{Example Program 2:}
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
run((a <-> b) -> c)
\end{Verbatim}

The 2nd example uses all of the capabilities of \lang{} about concurrency\\
In this example we are creating 3 jobs. You can see in this example that\\
we are stating in how many workers we want this script ot run. In line 3\\
we have a simple example on how to introduce dependencies in our language.\\
We have first the $(a <-> b)$. This states that the jobs `a' and `b' can\\
run concurrent in different servers. Afterwards we have $-> c$. With this\\
natation we state that the job `c' must run after the successful termination\\
of the previous job/s (in our example the `a' and `b' jobs).\\

You can see that \lang{} offers an easy way to distinguish between\\
the concurrent and not concurrent jobs. This will help developers and\\
not computer scientists to create easily distributable batch proccesses.\\
\\

\subsection*{Example Program 3:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
d = Job(name="d", "nimbledriod.py")
((a\mytilde>(b\mytilde c))\mytilde<d)
run((a,b,c,d)
\end{Verbatim}

This exmaples demonstrates the `soft' dependencies in \lang{}.\\
\underline{All of the soft dependencies must be in one line.} Otherwise only the\\
last line of dependecies are taken into consideration. All of the operators\\
are left associate but here we are using parenthesis in order to help\\
the user undestand how the soft dependencies works. In one line we \\
have all of the operators but we will explain the meening of every \\
parenthesis for clarifing everything. In the 5 line is where all \\
the magic happens. In order to understand the example will take the\\
parenthesis one at a time.\\
First we have the $(b\sim c)$. This means that these 2 jobs can run\\
sychronous if we have enough resources. \\
Second we have the $(a\sim>expr)$. This means that job `a' should run\\
before the \textit{expr}. \\
At last we have the $(expr\sim<d)$. This expression means that the \\
job `d' should run before the \textit{expr}.

\subsection*{Example Program 4:}
\begin{Verbatim}[numbers=left,commandchars=\\\{\}]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
d = Job(name="d", "nimbledriod.py")
c.add_dependency([b,d])
a\mytilde<b
run(a,b,c,d)
\end{Verbatim}

In the 4th example we can see the 3rd way to introduce dependencies.
With the funcion \textit{add\_dependency} we are adding to a job (here the `c')
a list of other jobs to be depended on. The execution then will start with the job
`b'. Thus we have the soft dependency at line 6. After the termination of job `b'
it will continue with `a'. The c is still blocked as it needs both jobs `b' and `d'.
As we do not have any dependency between `b' and `d', `d' will start to run in another
server. After the termination of `d' the job `c' is now ready to run.

%\subsection*{Example Program 5:}
%\begin{Verbatim}[numbers=left]
%func an_hour_after(Job j) {
%  return func () {
%    j.finish_time && j.finish_time - Time.now > Time.hour(1)
%  }
%}
%
%Job old_b = nil
%for i in range(0,10) {
%  a = Job(name="a", script='send_email_batch.rb')
%  b = Job(name="b", script='collect_data.rb')
%  b.add_func_dependency( an_hour_after(a) )
%  c = Job(name="c", script='analyze.py')
%  run(old_b -> a -> b -> c)
%  old_b = b
%}
%\end{Verbatim}
%This program makes measurements in 3 steps:
%Populate
%Collect Data
%Analyse
%\\

All programs are executed using the 'maestro' command.
\\
