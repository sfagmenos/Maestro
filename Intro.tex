\section{Introduction}
\label{sect:intro}

Frequently a user would like to allocate a pool of machines and conduct experimental evaluation represented in the format of a script. In a
broad sense, an end-user operates on a pool of machines and allocates jobs
represented in any scripting language. Our purpose is to build a well-defined,
easy-to-use, and agile programming language to enhance the user's ability to express complex semantics for job distribution and scheduling. There are many scenarios where semantics are needed to express dependencies for job execution, such as:
\begin{description}
\item[Jobs can depend on each other:] User needs to create and run jobs $A$,
$B$ in parallel, on a few workers. If both $A$ and $B$ succeed, job $C$ should
execute on some workers.
%And then you want to run job $C$ on some
%workers, only after both $A$ and $B$ succeeded.
\item[Jobs can depend on external factors:] Job $A$ should execute after 6.00 PM
and job $B$ should execute in machines with CPU-load less than 0.5.
\end{description}

Prior related work in this area includes the so-called infrastructure
configuration management frameworks, some of the most popular being
Puppet~\cite{puppet} and Chef~\cite{chef}. Typical infrastructure
configuration management allows system administrators express
infrastructure configuration dependencies. Our approach differs in that
it provides end-users the ability to express dependencies related to
job work-flows.

The rest of our document is structured as follows. In section~\ref{sect:desg} we
present the design of our language, in section~\ref{sect:spec} we underline
specifications and main features of our language. In section~\ref{sect:tech} we
describe the environment of our language, and then give an overview of what
programs will look like in section~\ref{sect:ex}. In section~\ref{sect:conc} we
give our concluding remarks.
