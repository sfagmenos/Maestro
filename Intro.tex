\section{Introduction}
\label{sect:intro}

It is common for a user to allocate a pool of machines and utilize
them to conduct experimental evaluation represented in the format of
a written program. In the broad sense, an end-user operates on a
pool of machines and allots jobs represented in any programming
language (scripted, interpreted, or compiled). Our purpose is to
build a well-defined, easy-to-use, and agile programming language
to enhance user's potential to express semantics amongst jobs and 
schedule execution based on well defined conditions. To gain a 
perspective on semantics when  defining job  execution, we will 
present some indicative possible dependencies amongst jobs. 
Dependencies may occur amongst jobs (eg., job A should execute if 
job B return 0, or job A should execute if job B fails), or may be 
amongst jobs and external parameters such as time or cpu load (e.g., 
job A should execute after 6.00 PM, job B should execute in machines 
with CPU-load less than 0.5). For the aforementioned nature of 
problems, we believe it is fruitful to provide users with an agile 
REPL environment to collectively express, distribute, and execute 
job tasks.

Prior related work in this area includes the so-called infrastructure 
configuration management frameworks, the most popular among which are 
Puppet~\cite{puppet} and Chef~\cite{chef}. Typical infrastructure 
configuration management intend to allow system  administrators express 
infrastructure configuration dependencies. Our approach differs in that 
it provides end-users the ability to express dependencies related to 
job work-flows. 

The rest of our document is structured as follows. In
section~\ref{sect:desg} we present the design of our language, in
section~\ref{sect:spec} we underline specifications and main
features of our language. In section~\ref{sect:tech} we describe
the environment of our language, in  section~\ref{sect:conc} we
give our concluding remarks.
