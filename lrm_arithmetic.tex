\documentclass[12pt]{article}
\usepackage{amssymb,amsmath,amsthm}
\usepackage[pdftex]{graphicx}
\usepackage{tikz}
\usepackage{ulem}
\usepackage{float}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode} 
\usepackage{bbm}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=4.5cm,rmargin=4.5cm,headheight=3cm,headsep=2cm,footskip=2cm}
\usepackage{amstext}
\linespread{1.5}

\title{Language Reference Manual Operators}

\author{Mathias Lecuyer, Vaggelis Atlidakis, Georgios Koloventzos, Yiren Lu}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
Maestro is a declarative language built to easily schedule jobs with hard and soft dependencies, locally or over the network.
Its goal is to provide a DSL to very quickly express dependencies between jobs and run them, either from the REPL or in a file.
It exposes high level functions and operators to declare complex logic. Maestro is meant for scripting, not to develop large
scale programs. It thus doesn't support functions, or even loops. However, it exposes a map/reduce interface that allows for
complex declarations.

\section{Lexical conventions}
\subsection{Whitespace}
Whitespaces are either a tab, a new line, or a white space. At least one white space is required to separate identifiers from
each other, and certain operators.

\subsection{Comments}
Comments are denoted by // and represent a comment that ends with the end of the current line.

\subsection{Identifiers}
An identifier is a sequence of letters, digits, and underscores. The first character must not be a digit.

\subsection{Keywords}
The following identifiers are used as keywords, and are reserved names:\\
if else

\subsection{Reserved Identifiers}
The following characters are reserved: $\texttt{+ - / * \% -> => <-> \textasciitilde>
\textasciitilde< \textasciitilde , ( ) "}$

\section{Types}
Maestro is dynamically typed and doesn't allow users to create new types.
\subsection{Basic Types}
\begin{description}
  \item[Job] A Job represents a program that can be ran on a worker. It encapsulates
    the path of the program and exposes outputs and errors.
  \item[Int] Ints are signed integers with arbitrary size.
  \item[String] Strings are delimited by " and have to be on one line.
  \item[Boolean] Boolean encapsulates true or false.
\end{description}

\subsection{Derived Types}
\begin{description}
  \item[Jobs] Jobs are ordered collections of one or more values. These
    objects need to be of type Job. The literal representation is a
    comma separated sequence of expressions surrounded by brackets ([ and ]).
\end{description}

\section{Scope}
Maestro is a scripting language used to quickly distributed interdependent jobs.
Its intended use is for scripts that glue tasks together, not to build and
maintain large programs. The scope of a variable is thus the entire script
(global scope), or the whole lifetime of the interpreter.

\section{Errors}
There are two kinds of errors in Maestro:
\begin{itemize}
  \item logic or type errors just make the program crash with an error
  message
  \item Job errors create a log on the local machine. If a later Job depend
  on this Job, the program will crash. If not, it will continue uninterrupted.
\end{itemize}

\section{Expressions}
\subsection{Identifier}
An identifier evaluates to the value of the corresponding variable.
\begin{description}
  \item[]expression: \hfill \\
    identifier
\end{description}

\subsection{Parenthesized expression}
A parenthesized expression takes the value of the evaluated expression.
\begin{description}
  \item[]expression: \hfill \\
    ( expression )
\end{description}

\subsection{Function call}
A function call is an expression. The arguments are comma separated and are evaluated
from left to right, before the call. It is possible to have 0 arguments.
\begin{description}
  \item[]expression: \hfill \\
    identifier ( expression-list )
\end{description}

\begin{description}
  \item[]expression-list: \hfill \\
    expression-list , expression \\
    | expression
\end{description}

\subsubsection{Built in functions}
The following functions are built into the language, and their names are reserved:\\
map reduce run Job\\
All return a Jobs (list of Jobs).
\begin{description}
  \item[Job(string, string..)] Job takes a string that is the path of a file to
    execute for the job, and any number of strings that will be passed as
    arguments. It returns a list with a Job object.
  \item[Wait(int)] Creates a Job which only sleeps for the given time. It can be inserted
  in the dependencies to wait between Jobs.
  % \item[range(int)] Returns a list of ints from 0 to int-1.
  \item[map(list, string)] the first list is a list of jobs that will run first, and their
    stdout will be concatenated. For every line in the concatenated stdout, map will create
    a Job with the string argument and the stdout line as an argument. It returns the list
    of created Jobs. This call is asynchronous.
  \item[reduce(list, string)] the first list is a list of jobs that will run first (usually the
    output of a map). String is the path to the reduce program. There will be one Job
    created with that program, with arguments that are the output from the previous reduce and
    the output of the next Job from the list. The first reduce will have nil as first argument.
  \item[run(list)] run takes an arbitrary number of comma separated lists of Jobs
    and runs them. If they have dependencies, these dependencies will run first.
\end{description}

\subsection{Jobs}
Jobs are created with the brackets notation. E.g. $list = [a, b, c, ...]$
\begin{description}
  \item[]expression: \hfill \\
    $[$ expression-list $]$
\end{description}

\subsection{Operators in expressions}
\begin{description}
  \item[]expression: \hfill \\
    expression OPERATOR expression
\end{description}

\subsection{Operators}
Operators are left associative and have the following precedences (same line
means same precedence, lower line means higher precedence):\\
$\texttt{-> => \textasciitilde> \textasciitilde<}$\\
$\texttt{+ - <-> \textasciitilde}$\\
$\texttt{/ * \%}$

\subsection{Operators description}
\begin{description}
\item[+] \hfil \\
The result is the sum of the expressions if they evaluate to an Int.\\
The result is the concatenation of the Jobs if both expressions evaluate to
a Jobs.\\
The result is the concatenation of the strings if both expressions evaluate to
a string.\\
The result is the concatenation of the string and the Int in a string format if
one expression evaluates to a string and the other to an Int.\\

\item[-] \hfil \\
The result is the difference of the expressions if they evaluate to an Int.

\item[*] \hfil \\
The result is the multiplication of the expressions if they evaluate to an Int.

\item[/] \hfil \\
The result is the Integer division of the expressions if they evaluate to an Int.\\
When dividing by 0, the program crashes.

\item[\%] \hfil \\
The \% operator yields the remainder from the division of the first expression by the second, if
both expressions evaluate to an Int.

\item[->] \hfil \\
The dependency operator (->) requires both expressions to be lists of Jobs.\\
The call is asynchronous and adds all Jobs in the right hand side list as dependencies
for all Jobs on the left hand side list.\\
It returns a list of Jobs that is the concatenation of both lists.

\item[=>] \hfil \\
The distributed dependency operator (=>) requires both expressions to be lists of Jobs.\\
The call is asynchronous and adds all Jobs in the right hand side list as dependencies
for all Jobs on the left hand side list. Moreover, the dependent Jobs (right
hand side)  will be ran on the same worker as the previous Job (left hand
side).\\
It returns a list of Jobs that is the concatenation of both lists.

\item[<->] \hfil \\
The parallel operator (<->) requires both expressions to be lists of Jobs.\\
The call is asynchronous and no dependencies are added. It is a visual way to
concatenate lists of Jobs.\\
It returns a list of Jobs that is the concatenation of both lists.

\item[\textasciitilde>] \hfil \\
The soft dependency operator (\textasciitilde>) requires both expressions to be lists of Jobs.\\
The call is asynchronous and puts all right hand side Jobs priority to be 1 less than the smallest
priority of the left hand side Jobs.\\
It returns a list of Jobs that is the concatenation of both lists.\\
A soft dependency is a priority indication: if more than one Job can run, Maestro will run the
one with higher priority, but there is no order guaranty, as opposed to dependencies.

\item[\textasciitilde<] \hfil \\
The soft dependency operator (\textasciitilde<) requires both expressions to be lists of Jobs.\\
The call is asynchronous and puts all right hand side Jobs priority to be 1 more than the biggest
priority of the left hand side Jobs.\\
It returns a list of Jobs that is the concatenation of both lists.\\
A soft dependency is a priority indication: if more than one Job can run, Maestro will run the
one with higher priority, but there is no order guaranty, as opposed to dependencies.

\item[\textasciitilde] \hfil \\
The soft parallel operator (\textasciitilde) requires both expressions to be lists of Jobs.\\
The call is asynchronous and no priorities are changed. It is a visual way to
concatenate lists of Jobs.\\
It returns a list of Jobs that is the concatenation of both lists.
\end{description}

\section{Assignments}
The value of the variable which name is the identifier value is replaced by the value of the expression
evaluates to. If the variable doesn't exist, it is created: the programmer doesn't need to declare the
variable beforehand.\\
The assignment is also an expression that has the variable final value as a value, which is useful for
one liners.\\
The default value of the variable is not determined.
\begin{description}
  \item[]expression: \hfill \\
    identifier = expression
\end{description}

\section{Statements}
Statements are executed in sequence.

\subsection{statement}
Statements are semicolon ended expressions.
\begin{description}
  \item[]statement: \hfill \\
    expression ;
\end{description}

% \subsection{statement-list}
% Most statement are expression statements, which have the form\\
% \begin{description}
  % \item[]statement-list: \hfill \\
    % statement statement-list \\
    % | statement
% \end{description}

% \subsection{Conditional statement}
% The two forms of the conditional statement are:
% \begin{description}
  % \item[]statement: \hfill \\
    % if ( expression ) { statement-list } \\
    % | if ( expression ) { statement-list } else { statement-list }\\
% \end{description}
% In both cases the expression is evaluated. If it is true, the first statements will be evaluated.
% If it is false and there is an else, the else statements will be evaluated.

% \subsection{.each statement}
% The each statement is a basic loop, and can be called on the Jobs type. 
% \begin{description}
  % \item[]statement: \hfill \\
    % expression .each ( identifier ) { statement-list }
% \end{description}
% The first expression has to evaluate to a list type. The identifier is the name of a variable (global scope
% like all variables) that will the assigned each Job in turn before running the statement list.

\subsection{Program definition}
A program consists of a list of statements evaluated from left to right.\\
\begin{description}
  \item[]program: \hfill \\
    statement program
\end{description}

\subsection{REPL}
In the REPL, inputs are read and evaluated every time the user hits enter.\\

\section{Grammar}
\begin{description}
  \item[]expression: \hfill \\
    expression + expression \\
    | expression - expression \\
    | expression * expression \\
    | expression / expression \\
    | expression \% expression \\
    | expression -> expression \\
    | expression => expression \\
    | expression <-> expression \\
    | expression \textasciitilde> expression \\
    | expression \textasciitilde< expression \\
    | expression \textasciitilde expression \\
\end{description}

\begin{description}
  \item[]expression: \hfill \\
    ( expression )
\end{description}

\begin{description}
  \item[]expression: \hfill \\
    identifier
\end{description}

\begin{description}
  \item[]expression: \hfill \\
    identifier ( expression-list )
\end{description}

\begin{description}
  \item[]expression-list: \hfill \\
    expression-list , expression \\
    | expression
\end{description}

\begin{description}
  \item[]expression: \hfill \\
    $[$ expression-list $]$
\end{description}

\begin{description}
  \item[]expression: \hfill \\
    identifier = expression
\end{description}

\begin{description}
  \item[]statement: \hfill \\
    expression ;
\end{description}

\begin{description}
  \item[]program: \hfill \\
    statement program
\end{description}
\end{document}

