\section{General Instructions}
\label{sect:general}

\subsection*{Define Workers in \lang{}}
For us to create the workers for \lang{} we will use \href{http://www.redis.io}{Redis}.
You can se the documentation of Redis \href{http://redis.io/documentation}{here}

\subsection*{Variables and Expressions in \lang{}}
Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.

Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals or characters in these variables.

Assigning Values to Variables:

Maestro variables do not have to be explicitly declared to reserve memory space. The declaration happens automatically when you assign a value to a variable. The equal sign (=) is used to assign values to variables.

The operand to the left of the = operator is the name of the variable and the operand to the right of the = operator is the value stored in the variable. 

Example:
\begin{verbatim}
a = 10
x = "john"
m = 1000.2
p = true
\end{verbatim}

This assigns the integer value 10 to the variable a, the string john to the variable x, the float value 1000.2 to the variable m and the Boolean value true to the variable p.

Another important type of variable that can be created in Maestro is the Job variable.

Example:
\begin{verbatim}
a = job ("abc.rb")
\end{verbatim}

Here, a is now a variable of 'job' type. 

Therefore, Maestro supports five datatypes;

Int
String
Float
Boolean
Job


\subsection*{Control Flows in \lang{}}
Control flow statements are used to execute a non-linear sequence of statements.
\subsubsection*{if-else statements}
The if keyword is used to execute a statement or block, if, and only if, a condition is fulfilled. Its syntax is:

if (condition) statement 

Here, condition is the expression that is being evaluated. If this condition is true, statement is executed. If it is false, statement is not executed (it is simply ignored), and the program continues right after the entire selection statement.

Example:
\begin{Verbatim}[numbers=left]
a = Job(....)
run(a)
if (a.perror()==0)
    print a.stdout()
    
\end{Verbatim}

Here, if executing Job a produces an error, this statement is ignored and nothing is printed. Stout is printed if and only if the job a is executed successfully.

If you want to include more than a single statement to be executed when the condition is fulfilled, these statements shall be enclosed in braces (\{\}), forming a block.

Example:

\begin{Verbatim}[numbers=left]
a = Job(....)
run(a)
if (a.perror()==0){
    print a.stdout()
    print "Job successful"
    }
\end{Verbatim}
Selection statements with if can also specify what happens when the condition is not fulfilled, by using the else keyword to introduce an alternative statement. Its syntax is:

if (condition) statement1 else statement2

where statement1 is executed in case condition is true, and in case it is not, statement2 is executed.

Example:
\begin{Verbatim}[numbers=left]
a = Job(....)
run(a)
if (a.perror()==0)
    print a.stdout()
else
    print a.error()
\end{Verbatim}

Here, if executing job a produces an error, the error code is printed. If the job is executed successfully, the output is printed.



\subsection*{Unique Operators in \lang{}}

In \lang{} language we are defining some operators with special meaning.\\
The operators $->$ and $<->$ for concurrency. Also the operators $\sim$,$\sim<$\\and $\sim>$ for the job dependancies.\\
\subsubsection*{The asynchronous $(->)$ operator}
In order to define a way that 2 process must run the one after the other\\
we implemented the asychronous operator. By this operator we declare that\\
the process at left of the arrow must first terminate successfully and\\
then the process at the right can start.
\subsubsection*{The concurrent $(<->)$ operator}
Unlike the asynchronous operator this operator denotes that this 2 jobs can\\
run parallel. This means that this 2 scripts can be send to 2 different\\
workers to execute. The failure of any of these jobs are not crucial to the\\
other.
\subsubsection*{The equal dependancy ($\sim$) operator}
The use of this operators states that these jobs should run concurrent if there\\
are enough resources.
\subsubsection*{The prior dependancy ($\sim>$) operator}
The use of this operators states that the job at left should run before the one\\
at the right.
\subsubsection*{The later dependancy ($\sim<$) operator}
The use of this operators states that the job at left should run after the one\\
at the right.
The 3 last operators are introducing the `soft' dependency as we call it in \lang{}\\
\subsection*{Classes and Functions in \lang{}}
\subsubsection*{Class $Job(string <name>, string <script\_path>, int <workers>=1)$}
New jobs are declared as objects of the $Job$ class using the implemented $new()$ method.\\
The $new()$ method requires as parameters;\\
$name$ which is the name of the job.\\
$script\_path$ which is the script to be executed.\\
$workers$ which an optional parameters to mention the number of workers to run the job on.\\\\
The default number of workers is 1.\\
Example:\\
Here we create 2 new jobs $b$ and $c$ as instances of \\the $Job$ class using the $new()$ method.
\begin{Verbatim}[numbers=left]
b = Job("b","xRay.rb",3)
c = Job("c","telesphorus.py")
\end{Verbatim}
\subsection*{Job Functions}
\subsubsection*{$Job.add\_dependency(List <dependencies>)$}
Function to create the dependency list of a job. The job we will be
able to run if and only if all this jobs terminated successfully.
\subsubsection*{$Job.stdout()$}
Function to return the output of the command. As it is the result of the script we should need to print it.
\subsubsection*{$Job.perror()$}
The perror function looks if the job executed properly in all of the workers. All of the return codes are stored in a list. So if any error occured in any worker the job knows in which worker happened.
\subsubsection*{$Job.error()$}
The error function returns the error message if any and also appends the ip of the worker that failed to execute the script.
\subsubsection*{$Job.run()$}
Function to actual run the script from $script\_path$. In general is creates a shell in the desired machine
and executes the script.
\subsubsection*{$Job.can\_run()$}
Function to go through all the dependencies and check if all terminated correctly. This will give us the notion
that this job can continue with execution.

\subsubsection*{Functions}

This section will present the main functions of \lang{}.
\subsubsection*{$run($\textit{expr}$)$}
The \textit{run} function takes the \textit{expr} and runs it in the workers we have introduced.
This is the distributed version of the function.
The \textit{expr} can have many interpretations. The \textit{expr} can be just just the jobs:
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
c = Job(name="c", "telesphorus.py")
run(a,b,c)
\end{Verbatim}
The \textit{expr} can also be a `hard' dependency string between jobs:
\begin{Verbatim}[numbers=left]
a = Job(name="a", script="abc.pl", workers=5)
b = Job(name="b", script="xRay.rb", workers=3)
run(a->b)
\end{Verbatim}
\subsubsection*{$run\_local($\textit{expr}$)$}
This is the local (as the names states!) version of the previous function.With this function we are running the jobs localy to our machine to test the code before we launch it with the previous function. It does not have any difference with the previous function in the sense of what \textit{expr} can be.
