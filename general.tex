\section{General Instructions}
\label{sect:general}

\subsection*{Define Workers in \lang{}}
For us to create the workers for \lang{} we will use \href{http://www.redis.io}{Redis}.
You can se the documentation of Redis \href{http://redis.io/documentation}{here}
\subsection*{Unique Operators in \lang{}}

In \lang{} language we are defining some operators with special meaning.\\
The operators $->$ and $<->$ for concurrency. Also the operators $~$,$~<$\\and $~>$ for the job dependancies.\\
\subsubsection*{The asynchronous $(->)$ operator}
In order to define a way that 2 process must run the one after the other\\
we implemented the asychronous operator. By this operator we declare that\\
the process at left of the arrow must first terminate successfully and\\
then the process at the right can start.
\subsubsection*{The concurrent $(<->)$ operator}
Unlike the asynchronous operator this operator denotes that this 2 jobs can\\
run parallel. This means that this 2 scripts can be send to 2 different\\
workers to execute. The failure of any of these jobs are not crucial to the\\
other.
\subsubsection*{The equal dependancy $(~)$ operator}
The use of this operators states that these jobs should run concurrent if there\\
are enough resources.
\subsubsection*{The prior dependancy $(~>)$ operator}
The use of this operators states that the job at left should run before the one\\
at the right.
\subsubsection*{The later dependancy $(~<)$ operator}
The use of this operators states that the job at left should run after the one\\
at the right.
\subsection*{Classes and Functions in \lang{}}
\subsubsection*{Class $Job(string <name>, string <script\_path>, int <workers>=1)$}
New jobs are declared as objects of the $Job$ class using the implemented $new()$ method.\\
The $new()$ method requires as parameters;\\
$name$ which is the name of the job.\\
$script\_path$ which is the script to be executed.\\
$workers$ which an optional parameters to mention the number of workers to run the job on.\\\\
The default number of workers is 1.\\
Example:\\
Here we create 2 new jobs $b$ and $c$ as instances of \\the $Job$ class using the $new()$ method.
\begin{verbatim}
b = Job("b","xRay.rb",3)
c = Job("c","telesphorus.py")
\end{verbatim}
\subsection*{Job Functions}
\subsubsection*{$Job.add\_dependency(List <dependencies>)$}
Function to create the dependency list of a job. The job we will be
able to run if and only if all this jobs terminated successfully.
\subsubsection*{$Job.stdout()$}
Function to return the output of the command. As it is the result of the script we should need to print it.
\subsubsection*{$Job.perror()$}
The perror function looks if the job executed properly in all of the workers. All of the return codes are stored in a list. So if any error occured in any worker the job knows in which worker happened.
\subsubsection*{$Job.error()$}
The error function returns the error message if any and also appends the ip of the worker that failed to execute the script.
\subsubsection*{$Job.run()$}
Function to actual run the script from $script\_path$. In general is creates a shell in the desired machine
and executes the script.
\subsubsection*{$Job.can\_run()$}
Function to go through all the dependencies and check if all terminated correctly. This will give us the notion
that this job can continue with execution.

Jobs are executed using the $run()$ method. The $run()$ method takes as parameter instances of the job class.
The dependencies between jobs have to be mentioned. Dependencies are mentioned using $->$ or $<->$ as described in the whitepaper.

\begin{verbatim}
 run ( ( a <-> b) -> c )
\end{verbatim}
