\section{Methodology}
\label{sec:test}
We did not rely on any existing Python unit-test frameworks for our testing purposes. Instead, we developed a customized testing engine for our project. The engine, described in the tests section, consists of several Python files. Each file contains a test written in Maestro that checks both the robustness of the compiler (i.e. its ability to identify and parse tokens), and the final output of the program. 

Presented below is a sample unit test.

\begin{center}
\begin{verbatim}
#!maestro
master("0.0.0.0:6379");
# check what happens when a job is run without being declared
a = Job('print.py', 'foo');
c = Job('print.py' 'bar');
run(a -> b -> c);  # Job b is not declared
\end{verbatim}
\end{center}

The test first checks if two Jobs are created successfully. The file \textit{print.py} is a Python program that writes the argument passed to it to a file \textit{check.txt}. Once executed, Job \textit{a} must run the argument \textit{foo} through the program \textit{print.py}. Similarly, Job \textit{b} must run the argument \textit{bar} through \textit{print.py}. 
Once the two Jobs have been created successfully, we attempt to pass an undeclared Job to the \textit{run} method, which executes a single Job or a list of Jobs in the given order. In this case, we check to see if the Maestro compiler identifies undeclared Job \textit{b} as an error and handles it elegantly. Once the test completes execution, we check the expected output against the output that was piped to \textit{check.txt} to confirm success or failure. 

We have a total of 15 testcases in our engine that test Maestro's  overall performance in different steps.

\section{Relevant Files and Descriptions}

\textbf{testframework.py}
\newline
\indent This is the main framework file. It can execute all Maestro test-cases or individual ones, depending on how it is called. 
\newline \textit{python testframework.py all} executes all test cases in the \textit{Tests} folder. Replacing \textit{all} with the test-name will execute individual tests. 
\newline
\newline
\textbf{run.sh}
\newline
\indent Similar to testframework.py, but written in bash script.
\newline
\newline
\textbf{Tests\textbackslash print.py}
\newline
\indent This program is run by every Job created in our test cases. It writes the argument that it receives into file \textit{check.txt}. 
\newline
\newline
\textbf{Tests\textbackslash}
\newline
\indent This folder contains all 75 Maestro test cases.
\newpage
\noindent\textbf{TestsOutput\textbackslash check.txt}
\newline
\indent The checkfile to which \textit{print.py} writes its output. We compare the contents of the file against the expected output to determine success or failure of a given Job.
\newline
\newline

\section{Selected Test Cases}
\begin{enumerate}

\item This test checks the performance of Maestro when presented with circular dependencies. 
\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b = Job("./tmp/test.sh", "foo");
c = Job("./tmp/test.sh", "chk");

run(a->b->c->a); //there is a circular dependency here
\end{verbatim}
Here job \textit{a} depends on \textit{b}, \textit{b} depends on \textit{c} and job \textit{c} in-turn depends on job \textit{a}.

\item This test checks the performance of Maestro on self dependencies.

\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b= Job("./tmp/test.sh", "bla");

run(a->a); //self-dependency
\end{verbatim}

Here job \textit{a} depends on itself.
\newpage
\noindent \item This test checks Maestro's response to an instance of imbalanced parentheses.

\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b= Job("./tmp/test.sh", "foo"; //Imbalanced parenthesis
c = Job("./tmp/test.sh", "bla");

run(a);
\end{verbatim}

\item This test case checks what happens when we provide a Map-Reduce job to Maestro.

\begin{verbatim}
#! maestro

a = Job("./cut.rb", "./all.txt", "3");

maps = map(a, "./count.rb", 3);
red = reduce(maps, "./reduce.rb");

run(a, maps, red);
\end{verbatim}

\end{enumerate}

