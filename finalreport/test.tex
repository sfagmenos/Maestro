\section{Methodology}
For our testing we do not rely on any existing Python unit-testing framework.
Instead, we have developed a customized testing engine for our project.
Our engine, encapsulated in the \textit{Tests} folder, comprises several Python
files, each of which corresponds to a Maestro test that checks both the
robustness of the compiler (i.e. its ability to identify and parse tokens),
and the final output of the program.
In what follows we presented a sample unit test.

\begin{center}
\begin{verbatim}
#!maestro
master("0.0.0.0:6379");
# check what happens when a job is run without being declared
a = Job('print.py', 'foo');
c = Job('print.py' 'bar');
a-> c
run(a, b, c);  # Job b is not declared
\end{verbatim}
\end{center}

% this test does not seem to check successful creation?
%This test first checks if jobs ``a'' and ``c'' are successfully created.

<<<<<<< HEAD
We have a total of 15 testcases in our engine that test Maestro's  overall performance in different steps.
=======
In the above test, the file \textit{print.py} is a Python program that writes
its argument to the file \textit{check.txt}. Once executed, Job ``a'' will
pass the argument \textit{foo} to the program \textit{print.py}. Similarly,
Job ``b'' will
pass the argument \textit{bar} to the program \textit{print.py}.
Once the two Jobs are successfully created, we attempt to pass an undeclared
Job ``b'' to the ``run'' method, which executes a single Job or a list of Jobs
according to their dependencies. With the above test, we check if
Maestro compiler identifies undeclared Job ``b'' and produces a diagnostic
error. Once the test completes execution, we check the expected output against
the output that was written to \textit{check.txt}, in order to evaluate success
or failure. In our engine, we have 75 testcases in total which helped us test
Maestro in different development stages.
>>>>>>> FETCH_HEAD

\section{Relevant Files and Descriptions}

\textbf{testframework.py}
\newline
\indent This is the main framework file. It can execute all Maestro test-cases
or individual ones, depending on how it is called.
\newline
\textit{python testframework.py all} executes all test cases in the
\textit{Tests} folder. Replacing \textit{all} with the name of a specific test
may be used to execute tests individually.
\newline
\newline
\textbf{run.sh}
\newline
\indent Similar to testframework.py, but written in bash script.
\newline
\newline
\textbf{Tests\textbackslash print.py}
\newline
\indent This program is run by every Job created in our test cases. It writes
the argument that it receives into file \textit{check.txt}.
\newline
\newline
\textbf{Tests\textbackslash}
\newline
\indent This folder contains all 75 Maestro test cases.
\newpage
\noindent\textbf{TestsOutput\textbackslash check.txt}
\newline
\indent The check file to which \textit{print.py} writes its output.
We compare the contents of the file against the expected output to determine
success or failure of a given Job.
\newline
\newline

\section{Selected Test Cases}
\begin{enumerate}

\item This test checks the behavior of Maestro in presence of a circular
dependency.
\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b = Job("./tmp/test.sh", "foo");
c = Job("./tmp/test.sh", "chk");

run(a->b->c->a); //there is a circular dependency here
\end{verbatim}
Here job ``a'' depends on job ``b'', job ``b'' depends on job ``c'', and job
``c'' in-turn depends on job ``a''.

\item This test checks the behavior of Maestro on self dependencies.
\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b= Job("./tmp/test.sh", "bla");

run(a->a); //self-dependency
\end{verbatim}
Here job \textit{a} depends on itself.
\newpage
<<<<<<< HEAD
\noindent \item This test checks Maestro's response to an instance of imbalanced parenthesis.
=======
\noindent \item This test check the behavior of Maestro on nested loops.
>>>>>>> FETCH_HEAD
\begin{verbatim}
#!maestro

a = Job("./tmp/test.sh", "bla");
b= Job("./tmp/test.sh", "foo"; //Imbalanced parenthesis
c = Job("./tmp/test.sh", "bla");

run(a);
\end{verbatim}

<<<<<<< HEAD
\item This test case checks what happens when we provide a Map-Reduce job to maestro.
=======
\item This test case checks what happens when we just run wait expressions in
circular.
>>>>>>> FETCH_HEAD
\begin{verbatim}
#! maestro

a = Job("./cut.rb", "./all.txt", "3");

maps = map(a, "./count.rb", 3);
red = reduce(maps, "./reduce.rb");

run(a, maps, red);
\end{verbatim}

\end{enumerate}
