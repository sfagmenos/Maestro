\section{Methodology}
For our testing we do not rely on any existing Python unit-testing framework.
Instead, we have developed a customized testing engine for our project.
Our engine, encapsulated in the \textit{Tests} folder, comprises several Python
files, each of which corresponds to a Maestro test that checks both the
robustness of the compiler (i.e. its ability to identify and parse tokens),
and the final output of the program.
In what follows we presented a sample unit test.

\begin{center}
\begin{verbatim}
#!maestro
master("0.0.0.0:6379");
# check what happens when a job is run without being declared
a = Job('print.py', 'foo');
c = Job('print.py' 'bar');
a-> c
run(a, b, c);  # Job b is not declared
\end{verbatim}
\end{center}

% this test does not seem to check successful creation?
%This test first checks if jobs ``a'' and ``c'' are successfully created.

In the above test, the file \textit{print.py} is a Python program that writes
its argument to the file \textit{check.txt}. Once executed, Job ``a'' will
pass the argument \textit{foo} to the program \textit{print.py}. Similarly,
Job ``b'' will
pass the argument \textit{bar} to the program \textit{print.py}.
Once the two Jobs are successfully created, we attempt to pass an undeclared
Job ``b'' to the ``run'' method, which executes a single Job or a list of Jobs
according to their dependencies. With the above test, we check if
Maestro compiler identifies undeclared Job ``b'' and produces a diagnostic
error. Once the test completes execution, we check the expected output against
the output that was written to \textit{check.txt}, in order to evaluate success
or failure. In our engine, we have 75 testcases in total which helped us test
Maestro in different development stages.

\section{Relevant Files and Descriptions}

\textbf{testframework.py}
\newline
\indent This is the main framework file. It can execute all Maestro test-cases
or individual ones, depending on how it is called.
\newline
\textit{python testframework.py all} executes all test cases in the
\textit{Tests} folder. Replacing \textit{all} with the name of a specific test
may be used to execute tests individually.
\newline
\newline
\textbf{run.sh}
\newline
\indent Similar to testframework.py, but written in bash script.
\newline
\newline
\textbf{Tests\textbackslash print.py}
\newline
\indent This program is run by every Job created in our test cases. It writes
the argument that it receives into file \textit{check.txt}.
\newline
\newline
\textbf{Tests\textbackslash}
\newline
\indent This folder contains all 75 Maestro test cases.
\newpage
\noindent\textbf{TestsOutput\textbackslash check.txt}
\newline
\indent The check file to which \textit{print.py} writes its output.
We compare the contents of the file against the expected output to determine
success or failure of a given Job.
\newline
\newline

\section{Selected Test Cases}
\begin{enumerate}

\item This test checks the behavior of Maestro in presence of a circular
dependency.
\begin{verbatim}
#!maestro
#master("0.0.0.0:6379")
# check hard circular dependencies with strings
a = Job("print.py", "cheer")
b = Job("print.py", "us")
c = Job("print.py" "on")
run(a -> b -> c -> a)
\end{verbatim}
Here job ``a'' depends on job ``b'', job ``b'' depends on job ``c'', and job
``c'' in-turn depends on job ``a''.

\item This test checks the behavior of Maestro on self dependencies.
\begin{verbatim}
#!maestro
#master("0.0.0.0:6379")
# check what happens when jobs depend on themselves
a = Job('print.py', 'foo')
run(a -> a -> a)
\end{verbatim}
\newpage
\noindent \item This test check the behavior of Maestro on nested loops.
\begin{verbatim}
#!maestro
#master("0.0.0.0:6379")
# check use of the operator *
c = 5
d = 8
range(d).each(var){
	range(c).each(varr){
		a = Job('print.py', var*varr)
		run(a)
	}

}
\end{verbatim}

\item This test case checks what happens when we just run wait expressions in
circular.
\begin{verbatim}
#!maestro
#master("0.0.0.0:6379")
# check what happens when we just run wait expressions in circular?
a = Job('print.py', 'cool')
b = Job('print.py', 'it')
c = Job('print.py', 'now')
run(wait(10) ~> wait(10) ~> c ~> wait(10))
\end{verbatim}

\end{enumerate}
